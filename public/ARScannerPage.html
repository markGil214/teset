<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>AR Scanner - Organ Visualization</title>
    <style>
      @import url("https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap");

      :root {
        --primary: #6366f1;
        --primary-hover: #4f46e5;
        --secondary: #ec4899;
        --success: #10b981;
        --warning: #f59e0b;
        --error: #ef4444;
        --glass-bg: rgba(255, 255, 255, 0.1);
        --glass-border: rgba(255, 255, 255, 0.2);
        --text-primary: #ffffff;
        --text-secondary: rgba(255, 255, 255, 0.8);
        --shadow: 0 10px 25px -5px rgba(0, 0, 0, 0.1);
        --radius: 12px;
        --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }

      body,
      html {
        margin: 0;
        padding: 0;
        font-family: "Inter", -apple-system, BlinkMacSystemFont, system-ui,
          sans-serif;
        overflow: hidden;
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: linear-gradient(135deg, #0f0f23 0%, #1a1a2e 100%);
        font-weight: 400;
      }

      .overlay {
        position: absolute;
        top: 110px; /* Below the floating buttons */
        left: 30px;
        right: 30px;
        z-index: 100;
        color: var(--text-primary);
        padding: 20px;
        text-align: center;
      }

      .loading-message {
        background: linear-gradient(135deg, var(--primary), #4338ca);
        padding: 12px 16px;
        margin-top: 12px;
        border-radius: var(--radius);
        color: white;
        font-weight: 500;
        box-shadow: 0 4px 16px rgba(99, 102, 241, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .error-message {
        background: linear-gradient(135deg, var(--warning), #f97316);
        padding: 12px 16px;
        margin-top: 12px;
        border-radius: var(--radius);
        color: white;
        font-weight: 500;
        box-shadow: 0 4px 16px rgba(245, 158, 11, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.1);
      }

      .back-button {
        background: linear-gradient(135deg, var(--error), #dc2626);
        padding: 12px 20px;
        margin-top: 12px;
        cursor: pointer;
        pointer-events: auto;
        position: relative;
        z-index: 100;
        border: none;
        color: white;
        border-radius: var(--radius);
        margin-right: 12px;
        font-weight: 500;
        font-size: 0.5rem;
        transition: var(--transition);
        box-shadow: 0 4px 16px rgba(239, 68, 68, 0.3);
      }

      .back-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(239, 68, 68, 0.4);
        background: linear-gradient(135deg, #dc2626, #b91c1c);
      }

      .info-button {
        background: linear-gradient(135deg, var(--primary), #4338ca);
        padding: 12px 20px;
        margin-top: 12px;
        cursor: pointer;
        pointer-events: auto;
        position: relative;
        z-index: 100;
        border: none;
        color: white;
        border-radius: var(--radius);
        font-weight: 500;
        font-size: 0.5rem;
        transition: var(--transition);
        box-shadow: 0 4px 16px rgba(99, 102, 241, 0.3);
      }

      .info-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(99, 102, 241, 0.4);
        background: linear-gradient(135deg, #4338ca, #3730a3);
      }

      /* Mobile responsiveness */
      @media (max-width: 768px) {
        .overlay {
          top: 110px;
          left: 20px;
          right: 20px;
          padding: 16px;
        }

        .back-button-container {
          top: 20px;
          left: 20px;
        }

        .back-button-floating {
          height: 50px;
          min-width: 160px;
          font-size: 0.5rem;
          padding: 0 20px;
        }

        .info-button-container {
          top: 20px;
          right: 20px;
        }

        .info-button-floating {
          width: 50px;
          height: 50px;
          font-size: 0.5rem;
        }

        .info-icon {
          font-size: 0.5rem;
        }
      }

      @media (max-width: 480px) {
        .overlay {
          top: 90px; /* Less space on smaller screens */
          left: 15px;
          right: 15px;
        }

        .back-button-container {
          top: 15px;
          left: 15px;
        }

        .back-button-floating {
          height: 45px;
          min-width: 140px;
          font-size: 0.5rem;
          padding: 0 16px;
        }

        .info-button-container {
          top: 15px;
          right: 15px;
        }

        .info-button-floating {
          width: 45px;
          height: 45px;
          font-size: 0.5rem;
        }

        .info-icon {
          font-size: 0.5rem;
        }

        .zoom-controls {
          bottom: 20px;
          right: 20px;
          padding: 12px;
        }

        .zoom-button {
          width: 48px;
          height: 48px;
          font-size: 0.5rem;
        }
      } /* Zoom Controls */
      .zoom-controls {
        position: absolute;
        bottom: 30px;
        right: 30px;
        z-index: 100;
        display: flex;
        flex-direction: column;
        gap: 12px;
        backdrop-filter: blur(20px);
        background: rgba(239, 68, 68, 0.1);
        border: 1px solid rgba(239, 68, 68, 0.2);
        border-radius: 20px;
        padding: 16px;
        box-shadow: 0 4px 16px rgba(239, 68, 68, 0.3);
      }

      .zoom-button {
        background: linear-gradient(135deg, #ef4444, #dc2626);
        color: white;
        border: 1px solid rgba(239, 68, 68, 0.2);
        border-radius: 50%;
        width: 56px;
        height: 56px;
        font-size: 0.5rem;
        font-weight: 600;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: var(--transition);
        backdrop-filter: blur(10px);
        position: relative;
        overflow: hidden;
        box-shadow: 0 4px 16px rgba(239, 68, 68, 0.4);
      }

      .zoom-button::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(135deg, #b91c1c, #991b1b);
        opacity: 0;
        transition: var(--transition);
        z-index: -1;
      }

      .zoom-button:hover::before {
        opacity: 0.8;
      }

      .zoom-button:hover {
        transform: scale(1.05);
        box-shadow: 0 8px 25px rgba(239, 68, 68, 0.6);
        border-color: #b91c1c;
      }

      .zoom-button:disabled {
        opacity: 0.4;
        cursor: not-allowed;
        transform: none;
      }

      .zoom-button:disabled:hover::before {
        opacity: 0;
      }

      .zoom-display {
        background: linear-gradient(135deg, #ef4444, #dc2626);
        color: white;
        padding: 12px 16px;
        border-radius: var(--radius);
        text-align: center;
        font-size: 0.5rem;
        font-weight: 600;
        border: 1px solid rgba(239, 68, 68, 0.2);
        backdrop-filter: blur(10px);
        margin-bottom: 4px;
        box-shadow: 0 4px 16px rgba(239, 68, 68, 0.3);
      }

      /* Confirmation Dialog */
      .confirmation-dialog {
        position: fixed;
        top: 0;
        left: 0;
        width: 100vw;
        height: 100vh;
        background: rgba(0, 0, 0, 0.8);
        backdrop-filter: blur(8px);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 300;
        animation: fadeIn 0.3s ease-out;
      }

      @keyframes fadeIn {
        from {
          opacity: 0;
        }
        to {
          opacity: 1;
        }
      }

      .dialog-content {
        background: linear-gradient(135deg, #ffffff, #f8fafc);
        padding: 24px;
        border-radius: 20px;
        text-align: center;
        max-width: 320px;
        margin: 20px;
        box-shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.25);
        border: 1px solid rgba(255, 255, 255, 0.2);
        animation: slideUp 0.3s ease-out;
      }

      @keyframes slideUp {
        from {
          opacity: 0;
          transform: translateY(20px) scale(0.95);
        }
        to {
          opacity: 1;
          transform: translateY(0) scale(1);
        }
      }

      #dialogTitle {
        font-size: 1.25rem;
        font-weight: 700;
        margin: 0 0 8px 0;
        background: linear-gradient(135deg, var(--primary), var(--secondary));
        background-clip: text;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
      }

      #dialogMessage {
        color: #64748b;
        font-size: 0.875rem;
        margin: 0 0 20px 0;
        line-height: 1.5;
      }

      .dialog-buttons {
        display: flex;
        gap: 10px;
        justify-content: center;
        margin-top: 20px;
      }

      .dialog-button {
        padding: 10px 20px;
        border: none;
        border-radius: var(--radius);
        cursor: pointer;
        font-size: 0.5rem;
        font-weight: 600;
        transition: var(--transition);
        min-width: 100px;
      }

      .confirm-button {
        background: linear-gradient(135deg, var(--primary), #4338ca);
        color: white;
        box-shadow: 0 4px 16px rgba(99, 102, 241, 0.3);
      }

      .confirm-button:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 25px rgba(99, 102, 241, 0.4);
      }

      .cancel-button {
        background: linear-gradient(135deg, #e2e8f0, #cbd5e1);
        color: #475569;
        box-shadow: 0 4px 16px rgba(71, 85, 105, 0.1);
      }

      .cancel-button:hover {
        transform: translateY(-2px);
        background: linear-gradient(135deg, #cbd5e1, #94a3b8);
      }

      .hidden {
        display: none !important;
      }

      @keyframes fadeInOut {
        0% {
          opacity: 0;
          transform: translate(-50%, -50%) translateY(20px) scale(0.8);
        }
        20% {
          opacity: 1;
          transform: translate(-50%, -50%) translateY(0) scale(1);
        }
        80% {
          opacity: 1;
          transform: translate(-50%, -50%) translateY(0) scale(1);
        }
        100% {
          opacity: 0;
          transform: translate(-50%, -50%) translateY(-20px) scale(0.8);
        }
      }

      .max-zoom-message {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: linear-gradient(135deg, var(--warning), #f97316);
        color: white;
        padding: 16px 24px;
        border-radius: var(--radius);
        font-weight: 600;
        font-size: 14px;
        z-index: 250;
        animation: fadeInOut 3s ease-in-out;
        box-shadow: 0 20px 25px -5px rgba(245, 158, 11, 0.3);
        border: 1px solid rgba(255, 255, 255, 0.2);
        backdrop-filter: blur(10px);
      }

      /* Add title styling */
      #scannerTitle {
        font-size: 1.125rem;
        font-weight: 600;
        margin-bottom: 16px;
        background: linear-gradient(135deg, var(--primary), var(--secondary));
        background-clip: text;
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
      }

      /* Independent Info Button */
      .info-button-container {
        position: absolute;
        top: 30px;
        right: 30px;
        z-index: 150;
      }

      .info-button-floating {
        background: linear-gradient(135deg, #ef4444, #dc2626);
        color: white;
        border: 1px solid var(--glass-border);
        border-radius: 50%;
        width: 60px;
        height: 60px;
        font-size: 0.5rem;
        font-weight: 700;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: var(--transition);
        backdrop-filter: blur(10px);
        box-shadow: 0 4px 16px rgba(239, 68, 68, 0.4);
        position: relative;
        overflow: hidden;
      }

      .info-icon {
        font-family: "Inter", -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
        font-size: 0.5rem;
        font-weight: 900;
        font-style: normal;
        color: white;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        letter-spacing: -2px;
        line-height: 1;
        position: relative;
        z-index: 2;
        user-select: none;
        -webkit-user-select: none;
        pointer-events: none;
      }

      /* Back Button Container for alignment */
      .back-button-container {
        position: absolute;
        top: 30px;
        left: 30px;
        z-index: 150;
      }

      .back-button-floating {
        background: linear-gradient(135deg, var(--error), #dc2626);
        color: white;
        border: 1px solid var(--glass-border);
        border-radius: 50px;
        height: 60px;
        padding: 0 24px;
        font-size: 0.5rem;
        font-weight: 600;
        cursor: pointer;
        display: flex;
        align-items: center;
        justify-content: center;
        gap: 8px;
        transition: var(--transition);
        backdrop-filter: blur(10px);
        box-shadow: 0 4px 16px rgba(239, 68, 68, 0.4);
        position: relative;
        overflow: hidden;
        white-space: nowrap;
        min-width: 180px;
      }

      .back-button-floating::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(135deg, #b91c1c, #991b1b);
        opacity: 0;
        transition: var(--transition);
        z-index: -1;
      }

      .back-button-floating:hover::before {
        opacity: 0.8;
      }

      .back-button-floating:hover {
        transform: scale(1.05);
        box-shadow: 0 8px 25px rgba(239, 68, 68, 0.6);
        border-color: #b91c1c;
      }

      .back-button-floating:active {
        transform: scale(0.95);
      }

      .info-button-floating::before {
        content: "";
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: linear-gradient(135deg, #b91c1c, #991b1b);
        opacity: 0;
        transition: var(--transition);
        z-index: -1;
      }

      .info-button-floating:hover::before {
        opacity: 0.8;
      }

      .info-button-floating:hover {
        transform: scale(1.1);
        box-shadow: 0 8px 25px rgba(239, 68, 68, 0.6);
        border-color: #b91c1c;
      }

      .info-button-floating:active {
        transform: scale(0.95);
      }
    </style>
  </head>
  <body>
    <!-- AR Scanner Interface -->
    <div id="arInterface">
      <!-- Floating Back Button -->
      <div class="back-button-container">
        <button class="back-button-floating" onclick="goBackToOrganSelection()">
          ‚Üê Back to Organ Selection
        </button>
      </div>

      <!-- Independent Info Button -->
      <div class="info-button-container">
        <button class="info-button-floating" onclick="openOrganInfo()">
          <span class="info-icon">i</span>
        </button>
      </div>

      <!-- Text overlay -->
      <div class="overlay">
        <div id="scannerTitle"></div>
        <div id="loadingMessage" class="loading-message hidden">
          üîÑ Loading 3D model...
        </div>
        <div id="errorMessage" class="error-message hidden">
          ‚ö†Ô∏è Model loading failed - showing fallback cube
        </div>
      </div>

      <!-- Zoom Controls -->
      <div class="zoom-controls">
        <div class="zoom-display" id="zoomDisplay">1.0x</div>
        <button class="zoom-button" id="zoomInBtn" onclick="handleZoomIn()">
          +
        </button>
        <button class="zoom-button" id="zoomOutBtn" onclick="handleZoomOut()">
          -
        </button>
        <button
          class="zoom-button"
          id="resetZoomBtn"
          onclick="handleResetZoom()"
        >
          ‚åÇ
        </button>
      </div>

      <!-- Max Zoom Message -->
      <div id="maxZoomMessage" class="max-zoom-message hidden">
        Maximum zoom reached!
      </div>
    </div>

    <!-- Confirmation Dialog -->
    <div id="confirmationDialog" class="confirmation-dialog hidden">
      <div class="dialog-content">
        <h3 id="dialogTitle">View Details?</h3>
        <p id="dialogMessage">Ready for detailed view?</p>
        <div class="dialog-buttons">
          <button
            class="dialog-button confirm-button"
            id="confirmButton"
            onclick="confirmDetailedModel()"
          >
            Yes
          </button>
          <button
            class="dialog-button cancel-button"
            onclick="cancelDetailedModel()"
          >
            Cancel
          </button>
        </div>
      </div>
    </div>
    <!-- Include THREE.js and THREEAR.js -->
    <script src="/vendor/three.101.min.js"></script>
    <script src="/vendor/GLTFLoader.js"></script>
    <script src="/THREEAR.js"></script>
    <script>
      // Protect against browser extension conflicts
      (function () {
        "use strict";

        // Store original location reference to prevent extension conflicts
        const originalLocation = window.location;

        // Prevent extensions from redefining location
        try {
          Object.defineProperty(window, "location", {
            value: originalLocation,
            writable: false,
            configurable: false,
          });
        } catch (e) {
          console.warn("Could not protect location object:", e);
        }
      })();

      // ZoomController class (converted from TypeScript)
      class ZoomController {
        constructor(initialZoom = 1.0, callbacks = {}) {
          this.zoomState = {
            currentZoom: initialZoom,
            isAnimating: false,
            thresholds: {
              normalView: 1.0,
              startSlicing: 1.5,
              showLabels: 2.0,
              maxDetail: 2.5,
            },
          };

          this.touchState = {
            isPinching: false,
            initialDistance: 0,
            baseZoom: initialZoom,
            lastTouchTime: 0,
          };

          this.callbacks = callbacks;
        }

        getCurrentZoom() {
          return this.zoomState.currentZoom;
        }

        isAnimating() {
          return this.zoomState.isAnimating;
        }

        setZoom(zoom, animate = true) {
          const clampedZoom = Math.max(0.5, Math.min(3.0, zoom));

          console.log(
            `ZoomController.setZoom - requested: ${zoom}, clamped: ${clampedZoom}, current: ${this.zoomState.currentZoom}`
          );

          if (zoom > 3.0 && this.zoomState.currentZoom === 3.0) {
            console.log("Max zoom reached - triggering callback");
            this.callbacks.onMaxZoomReached?.();
          }

          if (clampedZoom === this.zoomState.currentZoom) {
            console.log("Zoom unchanged, skipping");
            return;
          }

          this.checkThresholdCrossings(this.zoomState.currentZoom, clampedZoom);
          this.zoomState.currentZoom = clampedZoom;

          if (animate) {
            console.log("Starting zoom animation to", clampedZoom);
            this.animateZoom(clampedZoom);
          } else {
            console.log("Applying zoom immediately to", clampedZoom);
            this.callbacks.onZoomChange?.(clampedZoom);
          }
        }

        zoomIn(step = 0.2) {
          console.log(
            `ZoomController.zoomIn called - current: ${this.zoomState.currentZoom}, animating: ${this.zoomState.isAnimating}`
          );
          if (this.zoomState.isAnimating) {
            console.log("Zoom in blocked - animation in progress");
            return;
          }
          const newZoom = this.zoomState.currentZoom + step;
          console.log(
            `Zooming in from ${this.zoomState.currentZoom} to ${newZoom}`
          );
          this.setZoom(newZoom);
        }

        zoomOut(step = 0.2) {
          console.log(
            `ZoomController.zoomOut called - current: ${this.zoomState.currentZoom}, animating: ${this.zoomState.isAnimating}`
          );
          if (this.zoomState.isAnimating) {
            console.log("Zoom out blocked - animation in progress");
            return;
          }
          const newZoom = this.zoomState.currentZoom - step;
          console.log(
            `Zooming out from ${this.zoomState.currentZoom} to ${newZoom}`
          );
          this.setZoom(newZoom);
        }

        resetZoom() {
          console.log("ZoomController.resetZoom called");
          this.setZoom(1.0);
        }

        checkThresholdCrossings(oldZoom, newZoom) {
          const thresholds = this.zoomState.thresholds;
          for (const [key, value] of Object.entries(thresholds)) {
            if (
              (oldZoom < value && newZoom >= value) ||
              (oldZoom >= value && newZoom < value)
            ) {
              console.log(`Threshold crossed: ${key} at ${value}`);
              this.callbacks.onThresholdCrossed?.(key, newZoom);
            }
          }
        }

        animateZoom(targetZoom) {
          this.zoomState.isAnimating = true;
          this.callbacks.onZoomChange?.(targetZoom);
          setTimeout(() => {
            this.zoomState.isAnimating = false;
          }, 300);
        }

        handleTouchStart(e) {
          if (e.touches.length === 2) {
            e.preventDefault();
            this.touchState.isPinching = true;
            this.touchState.initialDistance = this.getTouchDistance(e.touches);
            this.touchState.baseZoom = this.zoomState.currentZoom;
            this.touchState.lastTouchTime = Date.now();
          }
        }

        handleTouchMove(e) {
          if (this.touchState.isPinching && e.touches.length === 2) {
            e.preventDefault();
            const currentDistance = this.getTouchDistance(e.touches);
            const scaleRatio =
              currentDistance / this.touchState.initialDistance;
            const newZoom = this.touchState.baseZoom * scaleRatio;
            this.setZoom(newZoom, false);
          }
        }

        handleTouchEnd(e) {
          if (e.touches.length < 2) {
            this.touchState.isPinching = false;
          }
        }

        getTouchDistance(touches) {
          const dx = touches[0].clientX - touches[1].clientX;
          const dy = touches[0].clientY - touches[1].clientY;
          return Math.sqrt(dx * dx + dy * dy);
        }

        destroy() {
          this.callbacks = {};
        }
      }

      // Global variables
      let currentOrgan = null;
      let modelLoading = false;
      let modelError = false;
      let currentZoom = 1.0;
      let isZoomAnimating = false;
      let showMaxZoomMessage = false;
      let showSlicedModel = false;
      let showConfirmation = false;
      let showSlicedModelRef = false;
      let zoomController = null;
      let organModel = null;
      let markerGroup = null;
      let baseScale = 0.5;
      let originalModel = null;
      let animationId = null;
      let renderer = null;
      let source = null; // Get organ data from localStorage
      function getSelectedOrgan() {
        const organData = localStorage.getItem("selectedOrgan");
        if (organData) {
          return JSON.parse(organData);
        }
        return null;
      }

      // Navigate back to organ selection
      function goBackToOrganSelection() {
        cleanup();
        localStorage.removeItem("selectedOrgan");
        // Use relative path for better routing compatibility
        window.location.href = "/";
      }

      // Open organ information page
      function openOrganInfo() {
        if (currentOrgan) {
          // Open organ-specific info page based on organ type
          let infoPageUrl = "";
          switch (currentOrgan.id) {
            case "heart":
              infoPageUrl = "HeartInfoPage.html";
              break;
            case "brain":
              infoPageUrl = "BrainInfoPage.html";
              break;
            case "kidney":
              infoPageUrl = "KidneyInfoPage.html";
              break;
            case "lungs":
              infoPageUrl = "LungsViewer.html";
              break;
            default:
              // Fallback to a general info page or alert
              alert(
                `Information about ${currentOrgan.name} is not available yet.`
              );
              return;
          }
          // Navigate in the same window instead of opening new tab
          window.location.href = infoPageUrl;
        }
      }

      // Get base scale for organ type
      function getBaseScale(organId) {
        switch (organId) {
          case "brain":
            return 2;
          case "heart":
            return 0.8;
          case "kidney":
            return 0.2;
          case "lungs":
            return 2;
          case "skin":
            return 0.5;
          default:
            return 0.5;
        }
      }

      // Initialize zoom controller
      function initializeZoomController() {
        baseScale = getBaseScale(currentOrgan.id);
        console.log(
          `Initializing zoom controller for ${currentOrgan.name} with base scale ${baseScale}`
        );

        zoomController = new ZoomController(1.0, {
          onZoomChange: (zoom) => {
            console.log(`ARScanner: Zoom changed to: ${zoom}x`);
            currentZoom = zoom;
            document.getElementById(
              "zoomDisplay"
            ).textContent = `${zoom.toFixed(1)}x`;

            // Check if we should switch back to original model when zooming out
            if (showSlicedModel && zoom < 3.0 && currentOrgan.id === "heart") {
              console.log(
                "Zoom reduced below max - switching back to original model"
              );
              restoreOriginalModel();
              showSlicedModel = false;
              showSlicedModelRef = false;
            }

            // Apply zoom to the 3D model
            if (organModel) {
              const newScale = baseScale * zoom;
              console.log(
                `ARScanner: Applying scale: ${newScale} (base: ${baseScale}, zoom: ${zoom})`
              );
              organModel.scale.set(newScale, newScale, newScale);
            } else {
              console.log(
                "ARScanner: Model not loaded yet - will apply zoom when loaded"
              );
            }
          },
          onThresholdCrossed: (threshold, zoom) => {
            console.log(
              `ARScanner: Zoom threshold crossed: ${threshold} at ${zoom}x`
            );
          },
          onMaxZoomReached: () => {
            if (currentOrgan.id === "heart") {
              console.log(
                "ARScanner: Max zoom reached - showing sliced heart confirmation"
              );
              showConfirmationDialog();
            } else if (currentOrgan.id === "brain") {
              console.log(
                "ARScanner: Max zoom reached - showing brain viewer confirmation"
              );
              showConfirmationDialog();
            } else if (currentOrgan.id === "kidney") {
              console.log(
                "ARScanner: Max zoom reached - showing kidney viewer confirmation"
              );
              showConfirmationDialog();
            } else if (currentOrgan.id === "lungs") {
              console.log(
                "ARScanner: Max zoom reached - showing lungs viewer confirmation"
              );
              showConfirmationDialog();
            } else {
              console.log("ARScanner: Max zoom reached - showing message");
              showMaxZoomMessageFunc();
            }
          },
        });

        console.log("Zoom controller initialized successfully");
      }

      // Initialize AR
      function initializeAR() {
        if (!currentOrgan) return;

        // Show loading
        setModelLoading(true);
        setModelError(false);

        // Initialize zoom controller
        initializeZoomController();

        // Prevent body scrolling
        document.body.style.overflow = "hidden";
        document.documentElement.style.overflow = "hidden"; // Initialize renderer (matching basic-cutout.html setup)
        renderer = new THREE.WebGLRenderer({
          antialias: true, // Enable antialiasing for sharper edges
          alpha: true,
        });
        renderer.setClearColor(new THREE.Color("lightgrey"), 0);
        renderer.setPixelRatio(window.devicePixelRatio); // Use full device pixel ratio for sharpness
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.domElement.style.position = "absolute";
        renderer.domElement.style.top = "0px";
        renderer.domElement.style.left = "0px";
        document.body.appendChild(renderer.domElement);

        var clock = new THREE.Clock();

        // Initialize scene and camera
        var scene = new THREE.Scene();
        var camera = new THREE.Camera();
        scene.add(camera);
        markerGroup = new THREE.Group();
        scene.add(markerGroup);

        source = new THREEAR.Source({ renderer, camera });
        THREEAR.initialize({ source: source })
          .then((controller) => {
            // Add lighting (matching basic-cutout.html pattern)
            var ambientLight = new THREE.AmbientLight(0xcccccc, 1.0);
            scene.add(ambientLight); // Load the 3D model
            console.log("Checking if GLTFLoader is available...");
            if (!THREE.GLTFLoader) {
              console.error(
                "GLTFLoader not available. Make sure GLTFLoader.js is loaded."
              );
              setModelLoading(false);
              setModelError(true);
              return;
            }

            var gltfLoader = new THREE.GLTFLoader();
            gltfLoader.load(
              currentOrgan.modelPath,
              (gltf) => {
                var model = gltf.scene;

                // Improve texture quality and sharpness
                model.traverse((child) => {
                  if (child.isMesh) {
                    // Improve material textures
                    if (child.material.map) {
                      child.material.map.generateMipmaps = true;
                      child.material.map.minFilter =
                        THREE.LinearMipmapLinearFilter;
                      child.material.map.magFilter = THREE.LinearFilter;
                      child.material.map.anisotropy =
                        renderer.capabilities.getMaxAnisotropy();
                    }
                    // Improve normal maps if present
                    if (child.material.normalMap) {
                      child.material.normalMap.generateMipmaps = true;
                      child.material.normalMap.minFilter =
                        THREE.LinearMipmapLinearFilter;
                      child.material.normalMap.magFilter = THREE.LinearFilter;
                    }
                    // Enable proper material updates
                    child.material.needsUpdate = true;
                  }
                });

                // Scale and position the model
                let scale, positionY;
                switch (currentOrgan.id) {
                  case "brain":
                    scale = 0.3;
                    positionY = 0.1;
                    break;
                  case "heart":
                    scale = 0.8;
                    positionY = 0;
                    break;
                  case "kidney":
                    scale = 0.2;
                    positionY = 0;
                    break;
                  case "lungs":
                    scale = 0.6;
                    positionY = 0;
                    break;
                  case "skin":
                    scale = 0.5;
                    positionY = 0;
                    break;
                  default:
                    scale = 0.5;
                    positionY = 0;
                }

                model.scale.set(scale, scale, scale);
                model.position.y = positionY;
                markerGroup.add(model);

                // Store model reference
                organModel = model;
                markerGroup.organModel = model;

                // Apply current zoom level
                if (zoomController) {
                  const currentZoomLevel = zoomController.getCurrentZoom();
                  if (currentZoomLevel !== 1.0) {
                    const newScale = scale * currentZoomLevel;
                    console.log(
                      `Applying initial zoom ${currentZoomLevel}x to loaded model: scale ${newScale}`
                    );
                    model.scale.set(newScale, newScale, newScale);
                  }
                }

                // Model loaded successfully
                setModelLoading(false);
                console.log(
                  `${currentOrgan.name} 3D model loaded successfully with scale: ${scale}`
                );
              },
              undefined,
              (error) => {
                console.error("Error loading 3D model:", error);
                setModelLoading(false);
                setModelError(true);

                // Fallback: add a simple cube
                var geometry = new THREE.CubeGeometry(1, 1, 1);
                var material = new THREE.MeshNormalMaterial({
                  transparent: true,
                  opacity: 0.5,
                  side: THREE.DoubleSide,
                });
                var cube = new THREE.Mesh(geometry, material);
                cube.position.y = geometry.parameters.height / 2;
                markerGroup.add(cube);
              }
            );

            var patternMarker = new THREEAR.PatternMarker({
              patternUrl: "/data/patt.hiro",
              markerObject: markerGroup,
            });

            controller.trackMarker(patternMarker); // Animation loop (matching basic-cutout.html pattern)
            var lastTimeMsec = 0;
            function animate(nowMsec) {
              animationId = requestAnimationFrame(animate);
              lastTimeMsec = lastTimeMsec || nowMsec - 1000 / 60;
              var deltaMsec = Math.min(200, nowMsec - lastTimeMsec);
              lastTimeMsec = nowMsec;

              // Update AR controller
              controller.update(source.domElement);

              // Rotate the 3D model if loaded - DISABLED AUTO-ROTATION
              // if (markerGroup.organModel) {
              //   if (!showSlicedModelRef) {
              //     markerGroup.organModel.rotation.y +=
              //       (deltaMsec / 2000) * Math.PI;
              //   }
              // }

              renderer.render(scene, camera);
            }
            animationId = requestAnimationFrame(animate);
          })
          .catch((error) => {
            console.error("THREEAR initialization failed:", error);
            setModelError(true);
            setModelLoading(false);
            // Clear any loading timeout
            if (window.loadingTimeout) {
              clearTimeout(window.loadingTimeout);
              window.loadingTimeout = null;
            }
            // Show error message to user
            const errorMsg = document.getElementById("error-message");
            if (errorMsg) {
              errorMsg.textContent =
                "Failed to initialize AR scanner. Please check camera permissions and try again.";
              errorMsg.style.display = "block";
            }
          });

        // Add touch event listeners
        document.addEventListener("touchstart", handleTouchStart, {
          passive: false,
        });
        document.addEventListener("touchmove", handleTouchMove, {
          passive: false,
        });
        document.addEventListener("touchend", handleTouchEnd, {
          passive: false,
        });
      }

      // Touch event handlers
      function handleTouchStart(e) {
        if (showConfirmation) return;

        const target = e.target;
        if (
          target &&
          (target.tagName === "BUTTON" ||
            target.closest("button") ||
            target.hasAttribute("data-ui-element") ||
            target.closest("[data-ui-element]") ||
            target.style.cursor === "pointer" ||
            target.closest('[style*="cursor: pointer"]'))
        ) {
          console.log("Touch on UI element detected, skipping zoom handler");
          return;
        }

        zoomController?.handleTouchStart(e);
      }

      function handleTouchMove(e) {
        if (showConfirmation) return;

        const target = e.target;
        if (
          target &&
          (target.tagName === "BUTTON" ||
            target.closest("button") ||
            target.hasAttribute("data-ui-element") ||
            target.closest("[data-ui-element]"))
        ) {
          return;
        }

        zoomController?.handleTouchMove(e);
      }

      function handleTouchEnd(e) {
        if (showConfirmation) return;

        const target = e.target;
        if (
          target &&
          (target.tagName === "BUTTON" ||
            target.closest("button") ||
            target.hasAttribute("data-ui-element") ||
            target.closest("[data-ui-element]"))
        ) {
          return;
        }

        zoomController?.handleTouchEnd(e);
      }

      // Zoom control handlers
      function handleZoomIn() {
        console.log("=== ARScanner: Zoom In button clicked ===");
        if (zoomController) {
          zoomController.zoomIn();
        }
        setIsZoomAnimating(true);
        setTimeout(() => setIsZoomAnimating(false), 300);
      }

      function handleZoomOut() {
        console.log("=== ARScanner: Zoom Out button clicked ===");
        if (zoomController) {
          zoomController.zoomOut();
        }
        setIsZoomAnimating(true);
        setTimeout(() => setIsZoomAnimating(false), 300);
      }

      function handleResetZoom() {
        console.log("=== ARScanner: Reset Zoom button clicked ===");
        if (zoomController) {
          zoomController.resetZoom();
        }
        setIsZoomAnimating(true);
        setTimeout(() => setIsZoomAnimating(false), 300);
      }

      // State management functions
      function setModelLoading(loading) {
        modelLoading = loading;
        const loadingEl = document.getElementById("loadingMessage");
        if (loading) {
          loadingEl.textContent = `üîÑ Loading ${
            currentOrgan?.name || ""
          } 3D model...`;
          loadingEl.classList.remove("hidden");
        } else {
          loadingEl.classList.add("hidden");
        }

        // Update zoom button states
        const disabled = loading || modelError;
        document.getElementById("zoomInBtn").disabled = disabled;
        document.getElementById("zoomOutBtn").disabled = disabled;
        document.getElementById("resetZoomBtn").disabled = disabled;
      }

      function setModelError(error) {
        modelError = error;
        const errorEl = document.getElementById("errorMessage");
        if (error) {
          errorEl.classList.remove("hidden");
        } else {
          errorEl.classList.add("hidden");
        }

        // Update zoom button states
        const disabled = modelLoading || error;
        document.getElementById("zoomInBtn").disabled = disabled;
        document.getElementById("zoomOutBtn").disabled = disabled;
        document.getElementById("resetZoomBtn").disabled = disabled;
      }

      function setIsZoomAnimating(animating) {
        isZoomAnimating = animating;
      }

      function showMaxZoomMessageFunc() {
        const messageEl = document.getElementById("maxZoomMessage");
        messageEl.classList.remove("hidden");
        setTimeout(() => {
          messageEl.classList.add("hidden");
        }, 3000);
      }

      function showConfirmationDialog() {
        showConfirmation = true;

        // Update dialog content based on organ type
        const dialogTitle = document.getElementById("dialogTitle");
        const dialogMessage = document.getElementById("dialogMessage");
        const confirmButton = document.getElementById("confirmButton");

        if (currentOrgan.id === "heart") {
          dialogTitle.textContent = "View Heart Details?";
          dialogMessage.textContent = "Explore sliced heart model?";
          confirmButton.textContent = "Yes";
        } else if (currentOrgan.id === "brain") {
          dialogTitle.textContent = "View Brain Details?";
          dialogMessage.textContent = "Explore brain anatomy?";
          confirmButton.textContent = "Yes";
        } else if (currentOrgan.id === "kidney") {
          dialogTitle.textContent = "View Kidney Details?";
          dialogMessage.textContent = "Explore kidney anatomy?";
          confirmButton.textContent = "Yes";
        } else if (currentOrgan.id === "lungs") {
          dialogTitle.textContent = "View Lungs Details?";
          dialogMessage.textContent = "Explore lungs anatomy?";
          confirmButton.textContent = "Yes";
        } else {
          dialogTitle.textContent = "View Details?";
          dialogMessage.textContent = "Explore detailed model?";
          confirmButton.textContent = "Yes";
        }

        document
          .getElementById("confirmationDialog")
          .classList.remove("hidden");

        // Hide the original model
        if (organModel && markerGroup) {
          originalModel = organModel;
          markerGroup.remove(organModel);
        }
      }
      function confirmDetailedModel() {
        if (currentOrgan.id === "heart") {
          console.log("User confirmed to view heart information");
          hideConfirmationDialog();
          // Navigate to the HeartInfoPage
          window.location.href = "HeartInfoPage.html";
        } else if (currentOrgan.id === "brain") {
          console.log("User confirmed to view brain information");
          hideConfirmationDialog();
          // Navigate to the BrainInfoPage
          window.location.href = "BrainInfoPage.html";
        } else if (currentOrgan.id === "kidney") {
          console.log("User confirmed to view kidney information");
          hideConfirmationDialog();
          // Navigate to the KidneyInfoPage
          window.location.href = "KidneyInfoPage.html";
        } else if (currentOrgan.id === "lungs") {
          console.log("User confirmed to view lungs information");
          hideConfirmationDialog();
          // Navigate to the LungsViewer page (no LungsInfoPage created yet)
          window.location.href = "LungsViewer.html";
        } else {
          console.log(
            "User confirmed to view detailed model - no specific page available"
          );
          hideConfirmationDialog();
        }
      }

      function cancelDetailedModel() {
        console.log("User cancelled viewing detailed model");
        hideConfirmationDialog();

        // Zoom out slightly to prevent triggering max zoom again
        if (zoomController) {
          zoomController.zoomOut();
        }

        // Restore the original model
        if (originalModel && markerGroup) {
          markerGroup.add(originalModel);
          organModel = originalModel;
          markerGroup.organModel = originalModel;
          console.log("Original model restored after cancellation");
        }
      }

      // Keep old functions for backward compatibility
      function confirmSlicedHeart() {
        confirmDetailedModel();
      }

      function cancelSlicedHeart() {
        cancelDetailedModel();
      }

      function hideConfirmationDialog() {
        showConfirmation = false;
        document.getElementById("confirmationDialog").classList.add("hidden");
      }

      function loadSlicedHeartModel() {
        if (!markerGroup || !organModel) return;

        console.log("Loading sliced heart model...");

        // Store reference to original model
        originalModel = organModel;

        // Remove current model from scene
        markerGroup.remove(organModel);

        // Load sliced heart model (fallback to original if not available)
        var gltfLoader = new THREE.GLTFLoader();
        gltfLoader.load(
          "/sliced_organs/heart.glb",
          (gltf) => {
            const slicedModel = gltf.scene;

            // Apply same scale and position as heart
            const scale = 0.8;
            const currentZoomLevel = zoomController?.getCurrentZoom() || 1.0;
            const finalScale = scale * currentZoomLevel;

            slicedModel.scale.set(finalScale, finalScale, finalScale);
            slicedModel.position.y = 0;

            // Add sliced model to scene
            markerGroup.add(slicedModel);

            // Update model reference
            organModel = slicedModel;
            markerGroup.organModel = slicedModel;
            showSlicedModel = true;
            showSlicedModelRef = true;

            console.log("Sliced heart model loaded successfully");
          },
          undefined,
          (error) => {
            console.error("Error loading sliced heart model:", error);
            // Fallback: keep original model
            if (originalModel) {
              markerGroup.add(originalModel);
              organModel = originalModel;
              markerGroup.organModel = originalModel;
            }
          }
        );
      }

      function restoreOriginalModel() {
        if (!markerGroup || !originalModel) return;

        console.log("Restoring original heart model...");

        // Remove current sliced model from scene
        if (organModel) {
          markerGroup.remove(organModel);
        }

        // Add original model back to scene
        markerGroup.add(originalModel);

        // Update model reference
        organModel = originalModel;
        markerGroup.organModel = originalModel;

        console.log("Original heart model restored successfully");
      }

      // Cleanup function
      function cleanup() {
        // Remove touch event listeners
        document.removeEventListener("touchstart", handleTouchStart);
        document.removeEventListener("touchmove", handleTouchMove);
        document.removeEventListener("touchend", handleTouchEnd);

        // Cancel animation frame
        if (animationId) {
          cancelAnimationFrame(animationId);
          animationId = null;
        }

        // Stop camera stream
        if (source && source.domElement && source.domElement.srcObject) {
          const stream = source.domElement.srcObject;
          stream.getTracks().forEach((track) => track.stop());
        }

        // Dispose of renderer
        if (renderer) {
          renderer.dispose();
          renderer = null;
        }

        // Remove renderer elements
        const rendererElements = document.querySelectorAll("canvas");
        rendererElements.forEach((canvas) => {
          if (canvas.parentElement === document.body) {
            document.body.removeChild(canvas);
          }
        });

        // Remove video elements
        const videoElements = document.querySelectorAll("video");
        videoElements.forEach((video) => {
          if (video.parentElement === document.body) {
            video.srcObject = null;
            document.body.removeChild(video);
          }
        });

        // Cleanup zoom controller
        if (zoomController) {
          zoomController.destroy();
          zoomController = null;
        }

        // Reset state
        organModel = null;
        markerGroup = null;
        originalModel = null;
        source = null;

        // Restore scrolling
        document.body.style.overflow = "";
        document.documentElement.style.overflow = "";
      }

      // Initialize the application
      document.addEventListener("DOMContentLoaded", function () {
        // Get organ data from localStorage
        currentOrgan = getSelectedOrgan();
        if (!currentOrgan) {
          alert("No organ selected. Redirecting to organ selection page.");
          window.location.href = "/";
          return;
        }

        // Initialize AR with selected organ
        initializeAR();
      });

      // Handle window resize
      window.addEventListener("resize", function () {
        if (renderer) {
          renderer.setSize(window.innerWidth, window.innerHeight);
        }
      });
    </script>
  </body>
</html>
